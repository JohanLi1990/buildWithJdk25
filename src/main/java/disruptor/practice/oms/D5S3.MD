# Day 5 — Session 3: Minimal-C Hybrid Architecture (Partitioned Disruptor + Per-Family Busy Gating)

## Goal
Implement a **hybrid (Option C “minimal”) pipeline** that:
- preserves **FIFO per familyKey (correlation family)**
- allows **concurrency across families** via worker threads (simulate 10–20ms work)
- keeps the **Disruptor consumer thread non-blocking** (dispatch only)
- is designed to later measure **p99 latency** (in a later session)

---

## Key constraints / assumptions
- `familyKey` is derived from `correlationId` (unbounded key space is OK).
- Tasks with the **same familyKey** must be processed **strictly FIFO** and **one-at-a-time**.
- Tasks with different familyKeys may run concurrently.
- Processing time per task is simulated to be **10–20ms** (e.g., emulate pricing server call).
- Current partition count: `N = 4`.

---

## Architecture overview (Minimal-C)
- Keep **Netty** for IO + decoding.
- Route each `TaskEvent` into **one of N Disruptor partitions** using `hash(familyKey)`.
- Each partition has:
  - **one Disruptor consumer thread** acting as a **dispatcher**
  - a **local FamilyScheduler** (per-partition family state map)
  - a **local worker pool** to execute tasks (because tasks are 10–20ms)
- Enforce per-family FIFO using **busy gating**:
  - for each family, allow **at most one in-flight task**
  - extra tasks of the same family are queued behind it

---

## ASCII diagram (Minimal-C)

```
             ┌─────────────────────┐
             │       Netty IO       │
             │  (event loop thread) │
             └──────────┬───────────┘
                        │ decode → TaskEvent
                        │ extract familyKey
                        ▼
             ┌─────────────────────┐
             │   Router / Hasher   │
             │ p = hash(familyKey) │
             │     & (N - 1)       │
             └───────┬─────────────┘
                     │
 ┌───────────────────┼───────────────────┬───────────────────┐
 ▼                   ▼                   ▼                   ▼

┌────────────┐      ┌────────────┐      ┌────────────┐      ┌────────────┐
│ Disruptor  │      │ Disruptor  │      │ Disruptor  │      │ Disruptor  │
│  P0 ring   │      │  P1 ring   │      │  P2 ring   │      │  P3 ring   │
└─────┬──────┘      └─────┬──────┘      └─────┬──────┘      └─────┬──────┘
      │                   │                   │                   │
      ▼                   ▼                   ▼                   ▼
┌────────────┐      ┌────────────┐      ┌────────────┐      ┌────────────┐
│ Consumer   │      │ Consumer   │      │ Consumer   │      │ Consumer   │
│ Thread P0  │      │ Thread P1  │      │ Thread P2  │      │ Thread P3  │
│ dispatcher │      │ dispatcher │      │ dispatcher │      │ dispatcher │
└─────┬──────┘      └─────┬──────┘      └─────┬──────┘      └─────┬──────┘
      │                   │                   │                   │
      ▼                   ▼                   ▼                   ▼
┌──────────────┐    ┌──────────────┐    ┌──────────────┐    ┌──────────────┐
│ FamilyMap P0 │    │ FamilyMap P1 │    │ FamilyMap P2 │    │ FamilyMap P3 │
│ (family→state)│   │ (family→state)│   │ (family→state)│   │ (family→state)│
└──────┬───────┘    └──────┬───────┘    └──────┬───────┘    └──────┬───────┘
       │                   │                   │                   │
       ▼                   ▼                   ▼                   ▼
┌────────────────┐  ┌────────────────┐  ┌────────────────┐  ┌────────────────┐
│ WorkerPool P0  │  │ WorkerPool P1  │  │ WorkerPool P2  │  │ WorkerPool P3  │
│ (k threads)    │  │ (k threads)    │  │ (k threads)    │  │ (k threads)    │
└────────────────┘  └────────────────┘  └────────────────┘  └────────────────┘

```

---

## Definitions
### familyKey
A `long` (or int) derived from `correlationId`. Unbounded range is fine.

### “Per-family busy gating”
A per-family rule enforced by scheduler:

- Each family has:
  - `busy` flag (0/1): whether a task from this family is currently executing
  - `pendingQueue`: FIFO queue of tasks waiting behind the in-flight one

Behavior:
- If family is idle → dispatch immediately and set busy=1
- If family is busy → enqueue task
- When a task completes → dispatch next queued task; if none → set busy=0

---

## Partition routing rules
### Base rule
```
partition = smearHash(familyKey) & (N - 1)
```
- Use a stable hash (avoid `%` if N is power of two).
- Ensure the same family always maps to the same partition.

### Special routing (optional, can postpone)
If you later identify synthetic families like **TBR** that can be huge:
- route them to a dedicated partition/lane (not required for Session 3 coding)

---

## Component responsibilities

### 1) Netty inbound handler
- Decode inbound bytes → `TaskEvent`
- Extract `familyKey` (derived from `correlationId`)
- Determine partition
- Attempt to publish to that partition’s ring buffer (`tryPublish` style)
- If partition ring buffer full → reject fast (e.g., `REJ:BUSY`)

### 2) Disruptor partition consumer thread (dispatcher)
**Must not block**.
Per event:
- call `familyScheduler.submit(event)` (local to this partition)
- do not perform 10–20ms processing here

### 3) Per-partition FamilyScheduler
Data:
- `ConcurrentHashMap<Long, FamilyState>` (local to partition)
  - acceptable for Session 3 because it is only “hot” within partition scope
- `FamilyState`:
  - `AtomicInteger busy` (0/1)
  - `Queue<TaskEvent> pending` (FIFO)

Algorithm:
- `submit(familyKey, task)`:
  - lookup/create `FamilyState`
  - if `busy` transitions 0→1: dispatch task to WorkerPool
  - else enqueue to `pending`

### 4) Per-partition WorkerPool
- `k` threads per partition (start with `k=2` recommended; tune later)
- Executes:
  - simulated work (sleep/random 10–20ms)
  - completion callback into scheduler to release family & dispatch next queued task

---

## Busy gating algorithm (pseudocode)

### On submit (dispatcher thread)
```java
state = map.getOrCreate(familyKey)
if (state.busy.CAS(0, 1)) {
    dispatch(task)
} else {
    state.pending.offer(task)
}
```

### On completion (worker thread)
```java
next = state.pending.poll()
if (next != null) {
    dispatch(next)           // keep busy=1
} else {
    state.busy.set(0)
    // race fix: a new task may have arrived after setting idle
    next = state.pending.poll()
    if (next != null && state.busy.CAS(0, 1)) {
        dispatch(next)
    }
}
```

Notes:
- This ensures exactly one in-flight task per family.
- Pending queue preserves FIFO per family.

---

## Backpressure & rejection points
- **Ring buffer full** (per partition): reject fast in Netty handler.
- (Optional later) **Per-family queue too deep**: reject / coalesce.

For Session 3, prefer to start with ring-buffer-based backpressure.

---

## Correctness requirements
- **FIFO per family**
  - For any familyKey, tasks must complete in the same order as submission.
- **Mutual exclusion per family**
  - No two tasks from the same family may execute concurrently.
- **Concurrency across families**
  - Different families should run in parallel (observed via worker threads).

---

## Testing plan (Session 3)
### Functional correctness test
- Generate tasks with fields:
  - `familyKey`
  - `seqInFamily` (monotonic per family)
- On completion, assert:
  - `seqInFamily` is strictly increasing per family (no reordering)

### Workload patterns
1) Many families:
   - e.g. 10k families, 100k tasks total
   - verify high concurrency and no reordering

2) One hot family:
   - e.g. family A has 30k tasks
   - plus other families mixed in
   - verify:
     - family A serialized
     - other families still progress concurrently

---

## Observability (counters/logs)
Per partition:
- `tasksIn` (count)
- `tasksDispatched` (count)
- `tasksCompleted` (count)
- `enqueuedDueToBusy` (count)
- `maxPendingDepthObserved` (sampled)
- `activeFamilies` (map size; optional)

---

## Tuning knobs (record only; don’t over-optimize yet)
- `N` partitions (currently 4)
- ring buffer size per partition (e.g., 1024 / 4096 / 8192)
- worker pool size per partition (`k`, start with 2)
- wait strategy (BusySpin/Yielding/Blocking) — pick simple first

---

## Non-goals for Session 3 (postpone)
- Dedicated TBR partition/lane
- Advanced bounded per-family queue + coalescing
- Full p99 latency measurement methodology (do later session)
- GC minimization / off-heap structures (do after correctness)

If you want, tomorrow when you start coding, 
paste your current `TaskEvent` fields + where you’re doing partition routing today (Netty handler vs elsewhere). 
I’ll help you place the `FamilyScheduler` in the cleanest spot so the dispatcher thread stays truly non-blocking.
